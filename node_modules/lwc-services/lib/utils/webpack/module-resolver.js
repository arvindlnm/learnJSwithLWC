"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const { LAYOUT, getConfig, isValidModuleName, getInfoFromId, npmmodules } = require('./module');
const EMPTY_STYLE = path.resolve(__dirname, 'mocks', 'empty-style.js');
/**
 * Webpack plugin to resolve LWC modules.
 */
module.exports = class ModuleResolver {
    constructor(config) {
        this.config = getConfig(config);
    }
    apply(resolver) {
        this.fs = resolver.fileSystem;
        resolver.hooks.module.tapAsync('LWC module', (req, ctx, cb) => this.resolveModule(req, ctx, cb));
        resolver.hooks.file.tapAsync('LWC CSS', (req, ctx, cb) => this.resolveFile(req, ctx, cb));
    }
    resolveModule(req, ctx, cb) {
        const { path: root, layout } = this.config.module;
        const { entries } = this.config;
        const { request, query, context: { issuer } } = req;
        if (request === '@lwc/engine') {
            return cb();
        }
        const mod = npmmodules[request];
        if (mod) {
            return cb(undefined, {
                path: mod.entry,
                query,
                file: true,
                resolved: true
            });
        }
        if (!issuer) {
            return cb();
        }
        let properPath = issuer.startsWith(root);
        if (!properPath) {
            properPath = entries.find((e) => issuer.startsWith(e));
        }
        if (!properPath) {
            return cb();
        }
        if (!isValidModuleName(request)) {
            return cb();
        }
        let resolved;
        if (layout === LAYOUT.STANDARD) {
            resolved = path.resolve(root, request, `${request}.js`);
        }
        else {
            const { ns, name } = getInfoFromId(request);
            resolved = path.resolve(root, ns, name, `${name}.js`);
        }
        this.fs.stat(resolved, (err) => {
            if (err !== null && err.code === 'ENOENT') {
                return cb(`Could not resolve ${request} as ${resolved}`);
            }
            return cb(err, {
                path: resolved,
                query,
                file: true,
                resolved: true
            });
        });
    }
    resolveFile(req, ctx, cb) {
        const { path: resourcePath, query } = req;
        const extname = path.extname(resourcePath);
        if (extname !== '.css') {
            return cb();
        }
        this.fs.stat(resourcePath, (err) => {
            if (err !== null && err.code === 'ENOENT') {
                return cb(null, {
                    path: EMPTY_STYLE,
                    query,
                    file: true,
                    resolved: false
                });
            }
            return cb();
        });
    }
};
