"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint no-production-assert: "off" */
const assert_1 = __importDefault(require("../shared/assert"));
const language_1 = require("../shared/language");
const attributes_1 = require("./attributes");
const invoker_1 = require("./invoker");
const vm_1 = require("./vm");
const element_1 = require("../env/element");
function generateDataDescriptor(options) {
    return language_1.assign({
        configurable: true,
        enumerable: true,
        writable: true,
    }, options);
}
function generateAccessorDescriptor(options) {
    return language_1.assign({
        configurable: true,
        enumerable: true,
    }, options);
}
let isDomMutationAllowed = false;
function unlockDomMutation() {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    isDomMutationAllowed = true;
}
exports.unlockDomMutation = unlockDomMutation;
function lockDomMutation() {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    isDomMutationAllowed = false;
}
exports.lockDomMutation = lockDomMutation;
function portalRestrictionErrorMessage(name, type) {
    return `The \`${name}\` ${type} is available only on elements that use the \`lwc:dom="manual"\` directive.`;
}
function getNodeRestrictionsDescriptors(node, options) {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    // getPropertyDescriptor here recursively looks up the prototype chain
    // and returns the first descriptor for the property
    const originalTextContentDescriptor = language_1.getPropertyDescriptor(node, 'textContent');
    const originalNodeValueDescriptor = language_1.getPropertyDescriptor(node, 'nodeValue');
    const { appendChild, insertBefore, removeChild, replaceChild } = node;
    return {
        appendChild: generateDataDescriptor({
            value(aChild) {
                if (this instanceof Element && language_1.isFalse(options.isPortal)) {
                    assert_1.default.logError(portalRestrictionErrorMessage('appendChild', 'method'), this);
                }
                return appendChild.call(this, aChild);
            },
        }),
        insertBefore: generateDataDescriptor({
            value(newNode, referenceNode) {
                if (!isDomMutationAllowed && this instanceof Element && language_1.isFalse(options.isPortal)) {
                    assert_1.default.logError(portalRestrictionErrorMessage('insertBefore', 'method'), this);
                }
                return insertBefore.call(this, newNode, referenceNode);
            },
        }),
        removeChild: generateDataDescriptor({
            value(aChild) {
                if (!isDomMutationAllowed && this instanceof Element && language_1.isFalse(options.isPortal)) {
                    assert_1.default.logError(portalRestrictionErrorMessage('removeChild', 'method'), this);
                }
                return removeChild.call(this, aChild);
            },
        }),
        replaceChild: generateDataDescriptor({
            value(newChild, oldChild) {
                if (this instanceof Element && language_1.isFalse(options.isPortal)) {
                    assert_1.default.logError(portalRestrictionErrorMessage('replaceChild', 'method'), this);
                }
                return replaceChild.call(this, newChild, oldChild);
            },
        }),
        nodeValue: generateAccessorDescriptor({
            get() {
                return originalNodeValueDescriptor.get.call(this);
            },
            set(value) {
                if (!isDomMutationAllowed && this instanceof Element && language_1.isFalse(options.isPortal)) {
                    assert_1.default.logError(portalRestrictionErrorMessage('nodeValue', 'property'), this);
                }
                originalNodeValueDescriptor.set.call(this, value);
            },
        }),
        textContent: generateAccessorDescriptor({
            get() {
                return originalTextContentDescriptor.get.call(this);
            },
            set(value) {
                if (this instanceof Element && language_1.isFalse(options.isPortal)) {
                    assert_1.default.logError(portalRestrictionErrorMessage('textContent', 'property'), this);
                }
                originalTextContentDescriptor.set.call(this, value);
            },
        }),
    };
}
function getElementRestrictionsDescriptors(elm, options) {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    const descriptors = getNodeRestrictionsDescriptors(elm, options);
    const originalInnerHTMLDescriptor = language_1.getPropertyDescriptor(elm, 'innerHTML');
    const originalOuterHTMLDescriptor = language_1.getPropertyDescriptor(elm, 'outerHTML');
    language_1.assign(descriptors, {
        innerHTML: generateAccessorDescriptor({
            get() {
                return originalInnerHTMLDescriptor.get.call(this);
            },
            set(value) {
                if (language_1.isFalse(options.isPortal)) {
                    assert_1.default.logError(portalRestrictionErrorMessage('innerHTML', 'property'), this);
                }
                return originalInnerHTMLDescriptor.set.call(this, value);
            },
        }),
        outerHTML: generateAccessorDescriptor({
            get() {
                return originalOuterHTMLDescriptor.get.call(this);
            },
            set(_value) {
                throw new TypeError(`Invalid attempt to set outerHTML on Element.`);
            },
        }),
    });
    return descriptors;
}
function getShadowRootRestrictionsDescriptors(sr, options) {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    // blacklisting properties in dev mode only to avoid people doing the wrong
    // thing when using the real shadow root, because if that's the case,
    // the component will not work when running with synthetic shadow.
    const originalQuerySelector = sr.querySelector;
    const originalQuerySelectorAll = sr.querySelectorAll;
    const originalAddEventListener = sr.addEventListener;
    const descriptors = getNodeRestrictionsDescriptors(sr, options);
    const originalInnerHTMLDescriptor = language_1.getPropertyDescriptor(sr, 'innerHTML');
    const originalTextContentDescriptor = language_1.getPropertyDescriptor(sr, 'textContent');
    language_1.assign(descriptors, {
        innerHTML: generateAccessorDescriptor({
            get() {
                return originalInnerHTMLDescriptor.get.call(this);
            },
            set(_value) {
                throw new TypeError(`Invalid attempt to set innerHTML on ShadowRoot.`);
            },
        }),
        textContent: generateAccessorDescriptor({
            get() {
                return originalTextContentDescriptor.get.call(this);
            },
            set(_value) {
                throw new TypeError(`Invalid attempt to set textContent on ShadowRoot.`);
            },
        }),
        addEventListener: generateDataDescriptor({
            value(type) {
                assert_1.default.invariant(!invoker_1.isRendering, `${invoker_1.vmBeingRendered}.render() method has side effects on the state of ${language_1.toString(sr)} by adding an event listener for "${type}".`);
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return originalAddEventListener.apply(this, arguments);
            },
        }),
        querySelector: generateDataDescriptor({
            value() {
                const vm = vm_1.getShadowRootVM(this);
                assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `this.template.querySelector() cannot be called during the construction of the custom element for ${vm} because no content has been rendered yet.`);
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return originalQuerySelector.apply(this, arguments);
            },
        }),
        querySelectorAll: generateDataDescriptor({
            value() {
                const vm = vm_1.getShadowRootVM(this);
                assert_1.default.isFalse(invoker_1.isBeingConstructed(vm), `this.template.querySelectorAll() cannot be called during the construction of the custom element for ${vm} because no content has been rendered yet.`);
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return originalQuerySelectorAll.apply(this, arguments);
            },
        }),
    });
    const BlackListedShadowRootMethods = {
        cloneNode: 0,
        getElementById: 0,
        getSelection: 0,
        elementsFromPoint: 0,
        dispatchEvent: 0,
    };
    language_1.forEach.call(language_1.getOwnPropertyNames(BlackListedShadowRootMethods), (methodName) => {
        const descriptor = generateAccessorDescriptor({
            get() {
                throw new Error(`Disallowed method "${methodName}" in ShadowRoot.`);
            },
        });
        descriptors[methodName] = descriptor;
    });
    return descriptors;
}
// Custom Elements Restrictions:
// -----------------------------
function getAttributePatched(attrName) {
    if (process.env.NODE_ENV !== 'production') {
        const vm = vm_1.getCustomElementVM(this);
        assertAttributeReflectionCapability(vm, attrName);
    }
    return element_1.getAttribute.apply(this, language_1.ArraySlice.call(arguments));
}
function setAttributePatched(attrName, _newValue) {
    const vm = vm_1.getCustomElementVM(this);
    if (process.env.NODE_ENV !== 'production') {
        assertAttributeReflectionCapability(vm, attrName);
    }
    element_1.setAttribute.apply(this, language_1.ArraySlice.call(arguments));
}
function setAttributeNSPatched(attrNameSpace, attrName, _newValue) {
    const vm = vm_1.getCustomElementVM(this);
    if (process.env.NODE_ENV !== 'production') {
        assertAttributeReflectionCapability(vm, attrName);
    }
    element_1.setAttributeNS.apply(this, language_1.ArraySlice.call(arguments));
}
function removeAttributePatched(attrName) {
    const vm = vm_1.getCustomElementVM(this);
    // marking the set is needed for the AOM polyfill
    if (process.env.NODE_ENV !== 'production') {
        assertAttributeReflectionCapability(vm, attrName);
    }
    element_1.removeAttribute.apply(this, language_1.ArraySlice.call(arguments));
}
function removeAttributeNSPatched(attrNameSpace, attrName) {
    const vm = vm_1.getCustomElementVM(this);
    if (process.env.NODE_ENV !== 'production') {
        assertAttributeReflectionCapability(vm, attrName);
    }
    element_1.removeAttributeNS.apply(this, language_1.ArraySlice.call(arguments));
}
function assertAttributeReflectionCapability(vm, attrName) {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    const propName = language_1.isString(attrName)
        ? attributes_1.getPropNameFromAttrName(language_1.StringToLowerCase.call(attrName))
        : null;
    const { elm, def: { props: propsConfig }, } = vm;
    if (isNodeFromVNode(elm) &&
        attributes_1.isAttributeLocked(elm, attrName) &&
        propsConfig &&
        propName &&
        propsConfig[propName]) {
        assert_1.default.logError(`Invalid attribute access for \`${attrName}\`. Use the corresponding property \`${propName}\` instead.`, elm);
    }
}
function getCustomElementRestrictionsDescriptors(elm, options) {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    const descriptors = getNodeRestrictionsDescriptors(elm, options);
    const originalAddEventListener = elm.addEventListener;
    const originalInnerHTMLDescriptor = language_1.getPropertyDescriptor(elm, 'innerHTML');
    const originalOuterHTMLDescriptor = language_1.getPropertyDescriptor(elm, 'outerHTML');
    const originalTextContentDescriptor = language_1.getPropertyDescriptor(elm, 'textContent');
    return language_1.assign(descriptors, {
        innerHTML: generateAccessorDescriptor({
            get() {
                return originalInnerHTMLDescriptor.get.call(this);
            },
            set(_value) {
                throw new TypeError(`Invalid attempt to set innerHTML on HTMLElement.`);
            },
        }),
        outerHTML: generateAccessorDescriptor({
            get() {
                return originalOuterHTMLDescriptor.get.call(this);
            },
            set(_value) {
                throw new TypeError(`Invalid attempt to set outerHTML on HTMLElement.`);
            },
        }),
        textContent: generateAccessorDescriptor({
            get() {
                return originalTextContentDescriptor.get.call(this);
            },
            set(_value) {
                throw new TypeError(`Invalid attempt to set textContent on HTMLElement.`);
            },
        }),
        addEventListener: generateDataDescriptor({
            value(type) {
                assert_1.default.invariant(!invoker_1.isRendering, `${invoker_1.vmBeingRendered}.render() method has side effects on the state of ${language_1.toString(elm)} by adding an event listener for "${type}".`);
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                return originalAddEventListener.apply(this, arguments);
            },
        }),
        // replacing mutators and accessors on the element itself to catch any mutation
        getAttribute: generateDataDescriptor({
            value: getAttributePatched,
        }),
        setAttribute: generateDataDescriptor({
            value: setAttributePatched,
        }),
        setAttributeNS: generateDataDescriptor({
            value: setAttributeNSPatched,
        }),
        removeAttribute: generateDataDescriptor({
            value: removeAttributePatched,
        }),
        removeAttributeNS: generateDataDescriptor({
            value: removeAttributeNSPatched,
        }),
    });
}
function getComponentRestrictionsDescriptors(cmp) {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    const originalSetAttribute = cmp.setAttribute;
    return {
        setAttribute: generateDataDescriptor({
            value(attrName, _value) {
                if (language_1.isString(attrName)) {
                    const propName = attributes_1.getPropNameFromAttrName(attrName);
                    const globalAttrName = attributes_1.globalHTMLProperties[propName] && attributes_1.globalHTMLProperties[propName].attribute;
                    // Check that the attribute name of the global property is the same as the
                    // attribute name being set by setAttribute.
                    if (attrName === globalAttrName) {
                        const { error } = attributes_1.globalHTMLProperties[propName];
                        if (error) {
                            assert_1.default.logError(error, vm_1.getComponentVM(this).elm);
                        }
                    }
                }
                // Typescript does not like it when you treat the `arguments` object as an array
                // @ts-ignore type-mismatch
                originalSetAttribute.apply(this, arguments);
            },
            configurable: true,
            enumerable: false,
        }),
        tagName: generateAccessorDescriptor({
            get() {
                throw new Error(`Usage of property \`tagName\` is disallowed because the component itself does not know which tagName will be used to create the element, therefore writing code that check for that value is error prone.`);
            },
            configurable: true,
            enumerable: false,
        }),
    };
}
function getLightingElementProtypeRestrictionsDescriptors(proto) {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    const descriptors = {};
    language_1.forEach.call(language_1.getOwnPropertyNames(attributes_1.globalHTMLProperties), (propName) => {
        if (propName in proto) {
            return; // no need to redefine something that we are already exposing
        }
        descriptors[propName] = generateAccessorDescriptor({
            get() {
                const { error, attribute } = attributes_1.globalHTMLProperties[propName];
                const msg = [];
                msg.push(`Accessing the global HTML property "${propName}" is disabled.`);
                if (error) {
                    msg.push(error);
                }
                else if (attribute) {
                    msg.push(`Instead access it via \`this.getAttribute("${attribute}")\`.`);
                }
                assert_1.default.logError(msg.join('\n'), vm_1.getComponentVM(this).elm);
            },
            set() {
                const { readOnly } = attributes_1.globalHTMLProperties[propName];
                if (readOnly) {
                    assert_1.default.logError(`The global HTML property \`${propName}\` is read-only.`);
                }
            },
        });
    });
    return descriptors;
}
function isNodeFromVNode(node) {
    return !!node.$fromTemplate$;
}
function markNodeFromVNode(node) {
    if (process.env.NODE_ENV === 'production') {
        // this method should never leak to prod
        throw new ReferenceError();
    }
    node.$fromTemplate$ = true;
}
exports.markNodeFromVNode = markNodeFromVNode;
function patchElementWithRestrictions(elm, options) {
    language_1.defineProperties(elm, getElementRestrictionsDescriptors(elm, options));
}
exports.patchElementWithRestrictions = patchElementWithRestrictions;
// This routine will prevent access to certain properties on a shadow root instance to guarantee
// that all components will work fine in IE11 and other browsers without shadow dom support.
function patchShadowRootWithRestrictions(sr, options) {
    language_1.defineProperties(sr, getShadowRootRestrictionsDescriptors(sr, options));
}
exports.patchShadowRootWithRestrictions = patchShadowRootWithRestrictions;
function patchCustomElementWithRestrictions(elm, options) {
    const restrictionsDescriptors = getCustomElementRestrictionsDescriptors(elm, options);
    const elmProto = language_1.getPrototypeOf(elm);
    language_1.setPrototypeOf(elm, language_1.create(elmProto, restrictionsDescriptors));
}
exports.patchCustomElementWithRestrictions = patchCustomElementWithRestrictions;
function patchComponentWithRestrictions(cmp) {
    language_1.defineProperties(cmp, getComponentRestrictionsDescriptors(cmp));
}
exports.patchComponentWithRestrictions = patchComponentWithRestrictions;
function patchLightningElementPrototypeWithRestrictions(proto) {
    language_1.defineProperties(proto, getLightingElementProtypeRestrictionsDescriptors(proto));
}
exports.patchLightningElementPrototypeWithRestrictions = patchLightningElementPrototypeWithRestrictions;
//# sourceMappingURL=restrictions.js.map